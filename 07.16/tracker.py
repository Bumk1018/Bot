# -*- coding: utf-8 -*-
"""Untitled4.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1xJC4o38lX2wINiktlTAQrak8h27PrMNR
"""

# -*- coding: utf-8 -*-
import os
import sys
import math
import subprocess
from collections import OrderedDict

# ───── 라이브러리 자동 설치 ─────
def install(package):
    subprocess.check_call([sys.executable, "-m", "pip", "install", package])

try:
    import cv2
except ImportError:
    install("opencv-python")
    import cv2

try:
    import numpy as np
except ImportError:
    install("numpy")
    import numpy as np

# ───── gdown을 이용한 Google Drive 다운로드 ─────
def download_with_gdown(file_id, output_name):
    try:
        import gdown
    except ImportError:
        install("gdown")
        import gdown
    url = f"https://drive.google.com/uc?id={file_id}"
    print(f"[INFO] gdown으로 Google Drive에서 '{output_name}' 다운로드 중...")
    gdown.download(url, output_name, quiet=False)
    print(f"[INFO] 다운로드 완료: {output_name}")

# ───── 기본 설정값 ─────
METER_PER_PIXEL = 0.05
FPS = 30
VIDEO_FILE = "output.mp4"
DRIVE_FILE_ID = "11tWiihrFVCWOKkqg4_FqnicZZA_GRHkc"

# ───── 차량 정보 클래스 ─────
class VehicleInfo:
    def __init__(self, object_id):
        self.id = object_id
        self.positions = []
        self.speeds = []
        self.directions = []

    def update(self, centroid, frame_time):
        self.positions.append((centroid, frame_time))
        if len(self.positions) >= 2:
            (x1, y1), t1 = self.positions[-2]
            (x2, y2), t2 = self.positions[-1]
            pixel_dist = math.hypot(x2 - x1, y2 - y1)
            real_dist = pixel_dist * METER_PER_PIXEL
            time_diff = t2 - t1
            if time_diff > 0:
                speed = real_dist / time_diff
                direction = math.degrees(math.atan2(y2 - y1, x2 - x1))
                self.speeds.append(speed)
                self.directions.append(direction)

# ───── 센트로이드 기반 트래커 ─────
class CentroidTracker:
    def __init__(self, max_disappeared=10):
        self.next_id = 0
        self.objects = OrderedDict()
        self.disappeared = OrderedDict()
        self.vehicle_info = {}
        self.max_disappeared = max_disappeared

    def register(self, centroid):
        self.objects[self.next_id] = centroid
        self.disappeared[self.next_id] = 0
        self.vehicle_info[self.next_id] = VehicleInfo(self.next_id)
        self.next_id += 1

    def deregister(self, object_id):
        del self.objects[object_id]
        del self.disappeared[object_id]
        del self.vehicle_info[object_id]

    def update(self, input_centroids, frame_time):
        if len(self.objects) == 0:
            for centroid in input_centroids:
                self.register(centroid)
        else:
            object_ids = list(self.objects.keys())
            object_centroids = list(self.objects.values())

            D = np.linalg.norm(np.array(object_centroids)[:, np.newaxis] - np.array(input_centroids), axis=2)
            rows = D.min(axis=1).argsort()
            cols = D.argmin(axis=1)[rows]

            used_rows, used_cols = set(), set()
            for (row, col) in zip(rows, cols):
                if row in used_rows or col in used_cols:
                    continue
                object_id = object_ids[row]
                self.objects[object_id] = input_centroids[col]
                self.vehicle_info[object_id].update(input_centroids[col], frame_time)
                self.disappeared[object_id] = 0
                used_rows.add(row)
                used_cols.add(col)

            unused_rows = set(range(0, D.shape[0])) - used_rows
            unused_cols = set(range(0, D.shape[1])) - used_cols

            for row in unused_rows:
                object_id = object_ids[row]
                self.disappeared[object_id] += 1
                if self.disappeared[object_id] > self.max_disappeared:
                    self.deregister(object_id)

            for col in unused_cols:
                self.register(input_centroids[col])

        return self.objects, self.vehicle_info

# ───── 차량 탐지 함수 (ROI 적용) ─────
def detect_vehicles(frame):
    height = frame.shape[0]
    roi_start = int(height * 0.25)
    roi = frame[roi_start:, :]

    gray = cv2.cvtColor(roi, cv2.COLOR_BGR2GRAY)
    blurred = cv2.GaussianBlur(gray, (5, 5), 0)
    _, thresh = cv2.threshold(blurred, 150, 255, cv2.THRESH_BINARY)
    contours, _ = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

    centroids = []
    for cnt in contours:
        area = cv2.contourArea(cnt)
        if 800 < area < 5000:
            M = cv2.moments(cnt)
            if M["m00"] != 0:
                cX = int(M["m10"] / M["m00"])
                cY = int(M["m01"] / M["m00"]) + roi_start  # ROI 보정
                centroids.append((cX, cY))
    return centroids

# ───── 메인 함수 ─────
def main():
    if not os.path.exists(VIDEO_FILE):
        download_with_gdown(DRIVE_FILE_ID, VIDEO_FILE)

    cap = cv2.VideoCapture(VIDEO_FILE)
    if not cap.isOpened():
        print("[ERROR] 영상 파일을 열 수 없습니다.")
        return

    tracker = CentroidTracker()
    frame_idx = 0

    fourcc = cv2.VideoWriter_fourcc(*"mp4v")
    width = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH))
    height = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))
    out = cv2.VideoWriter("result.mp4", fourcc, FPS, (width, height))

    while True:
        ret, frame = cap.read()
        if not ret:
            break

        frame_time = frame_idx / FPS
        centroids = detect_vehicles(frame)
        objects, vehicle_info = tracker.update(centroids, frame_time)

        for object_id, centroid in objects.items():
            x, y = centroid
            cv2.circle(frame, (x, y), 5, (0, 255, 0), -1)
            info = vehicle_info[object_id]
            speed = info.speeds[-1] if info.speeds else 0.0
            direction = info.directions[-1] if info.directions else 0.0
            label = f"ID:{object_id}  {speed:.1f}m/s  {direction:.0f}deg"
            cv2.putText(frame, label, (x - 30, y - 15), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 255, 255), 1)

        cv2.imshow("Vehicle Tracking", frame)
        out.write(frame)

        if cv2.waitKey(1) == 27:  # ESC 키 종료
            break

        frame_idx += 1

    cap.release()
    out.release()
    cv2.destroyAllWindows()

if __name__ == "__main__":
    main()